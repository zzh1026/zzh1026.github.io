<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="声明本文为转载文章！尊重原创的劳动果实，严禁剽窃 本文转载于：https://blog.csdn.net/guolin_blog/article/details/70215985 出自于：郭霖的博客 本篇为Glide系列的第四篇： 玩转Glide的回调与监听 本文主要用于个人学习回顾使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Android图片加载框架最全解析（四），玩转Glide的回调与监听">
<meta property="og:url" content="http://zhaozehui.cn/2018/06/11/Android图片加载框架最全解析（四），玩转Glide的回调与监听/index.html">
<meta property="og:site_name" content="zzh1026it">
<meta property="og:description" content="声明本文为转载文章！尊重原创的劳动果实，严禁剽窃 本文转载于：https://blog.csdn.net/guolin_blog/article/details/70215985 出自于：郭霖的博客 本篇为Glide系列的第四篇： 玩转Glide的回调与监听 本文主要用于个人学习回顾使用">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://img-blog.csdn.net/20170614222823388?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170615212142394">
<meta property="og:image" content="https://img-blog.csdn.net/20170615225048126">
<meta property="og:image" content="https://img-blog.csdn.net/20170616223448840">
<meta property="og:image" content="https://img-blog.csdn.net/20170616223618749">
<meta property="og:image" content="https://img-blog.csdn.net/20170617112709246?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2018-06-11T06:56:58.278Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android图片加载框架最全解析（四），玩转Glide的回调与监听">
<meta name="twitter:description" content="声明本文为转载文章！尊重原创的劳动果实，严禁剽窃 本文转载于：https://blog.csdn.net/guolin_blog/article/details/70215985 出自于：郭霖的博客 本篇为Glide系列的第四篇： 玩转Glide的回调与监听 本文主要用于个人学习回顾使用">
<meta name="twitter:image" content="https://img-blog.csdn.net/20170614222823388?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zhaozehui.cn/2018/06/11/Android图片加载框架最全解析（四），玩转Glide的回调与监听/"/>





  <title>Android图片加载框架最全解析（四），玩转Glide的回调与监听 | zzh1026it</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e1d3207f597e5755f17072f0711098cc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zzh1026it</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每天都是新的开始</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhaozehui.cn/2018/06/11/Android图片加载框架最全解析（四），玩转Glide的回调与监听/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zzh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/headers.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zzh1026it">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android图片加载框架最全解析（四），玩转Glide的回调与监听</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-11T09:26:46+08:00">
                2018-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/图片加载/" itemprop="url" rel="index">
                    <span itemprop="name">图片加载</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/图片加载/Glide解析（转载）/" itemprop="url" rel="index">
                    <span itemprop="name">Glide解析（转载）</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p><strong>本文为转载文章！尊重原创的劳动果实，严禁剽窃</strong></p>
<p>本文转载于：<a href="https://blog.csdn.net/guolin_blog/article/details/70215985" title="Android图片加载框架最全解析（四），玩转Glide的回调与监听" target="_blank" rel="noopener">https://blog.csdn.net/guolin_blog/article/details/70215985</a></p>
<p>出自于：<a href="https://blog.csdn.net/guolin_blog" target="_blank" rel="noopener">郭霖的博客</a></p>
<p>本篇为Glide系列的第四篇： <strong>玩转Glide的回调与监听</strong></p>
<p><strong>本文主要用于个人学习回顾使用</strong></p>
<a id="more"></a>
<p>大家好，今天我们继续学习Glide。</p>
<p>在上一篇文章当中，我带着大家一起深入探究了Glide的缓存机制，我们不光掌握了Glide缓存的使用方法，还通过源码分析对缓存的工作原理进行了了解。虽说上篇文章和本篇文章的内容关系并不是很大，不过感兴趣的朋友还是可以去阅读一下 <a href="https://zhaozehui.cn/2018/06/08/Android%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%8C%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6Glide%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">Android图片加载框架最全解析（三），深入探究Glide的缓存机制</a> 。</p>
<p>今天是这个Glide系列的第四篇文章，我们又要选取一个新的功能模块开始学习了，那么就来研究一下Glide的回调和监听功能吧。今天的学习模式仍然是以基本用法和源码分析相结合的方式来进行的，当然，本文中的源码还是建在第二篇源码分析的基础之上，还没有看过这篇文章的朋友，建议先去阅读 <a href="http://blog.csdn.net/guolin_blog/article/details/53939176" target="_blank" rel="noopener">Android图片加载框架最全解析（二），从源码的角度理解Glide的执行流程</a> 。</p>
<h1 id="回调的源码实现"><a href="#回调的源码实现" class="headerlink" title="回调的源码实现"></a>回调的源码实现</h1><p>作为一名Glide老手，相信大家对于Glide的基本用法已经非常熟练了。我们都知道，使用Glide在界面上加载并展示一张图片只需要一行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this).load(url).into(imageView);</span><br></pre></td></tr></table></figure>
<p>而在这一行代码的背后，Glide帮我们执行了成千上万行的逻辑。其实在第二篇文章当中，我们已经分析了这一行代码背后的完整执行流程，但是这里我准备再带着大家单独回顾一下回调这部分的源码，这将有助于我们今天这篇文章的学习。</p>
<p>首先来看一下into()方法，这里我们将ImageView的实例传入到into()方法当中，Glide将图片加载完成之后，图片就能显示到ImageView上了。这是怎么实现的呢？我们来看一下into()方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Target&lt;TranscodeType&gt; into(ImageView view) &#123;</span><br><span class="line">    Util.assertMainThread();</span><br><span class="line">    if (view == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;You must pass in a non null View&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!isTransformationSet &amp;&amp; view.getScaleType() != null) &#123;</span><br><span class="line">        switch (view.getScaleType()) &#123;</span><br><span class="line">            case CENTER_CROP:</span><br><span class="line">                applyCenterCrop();</span><br><span class="line">                break;</span><br><span class="line">            case FIT_CENTER:</span><br><span class="line">            case FIT_START:</span><br><span class="line">            case FIT_END:</span><br><span class="line">                applyFitCenter();</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                // Do nothing.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return into(glide.buildImageViewTarget(view, transcodeClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最后一行代码会调用glide.buildImageViewTarget()方法构建出一个Target对象，然后再把它传入到另一个接收Target参数的into()方法中。Target对象则是用来最终展示图片用的，如果我们跟进到glide.buildImageViewTarget()方法中，你会看到如下的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ImageViewTargetFactory &#123;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;Z&gt; Target&lt;Z&gt; buildTarget(ImageView view, Class&lt;Z&gt; clazz) &#123;</span><br><span class="line">        if (GlideDrawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            return (Target&lt;Z&gt;) new GlideDrawableImageViewTarget(view);</span><br><span class="line">        &#125; else if (Bitmap.class.equals(clazz)) &#123;</span><br><span class="line">            return (Target&lt;Z&gt;) new BitmapImageViewTarget(view);</span><br><span class="line">        &#125; else if (Drawable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            return (Target&lt;Z&gt;) new DrawableImageViewTarget(view);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Unhandled class: &quot; + clazz</span><br><span class="line">                    + &quot;, try .as*(Class).transcode(ResourceTranscoder)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>buildTarget()方法会根据传入的class参数来构建不同的Target对象，如果你在使用Glide加载图片的时候调用了asBitmap()方法，那么这里就会构建出BitmapImageViewTarget对象，否则的话构建的都是GlideDrawableImageViewTarget对象。至于上述代码中的DrawableImageViewTarget对象，这个通常都是用不到的，我们可以暂时不用管它。</p>
<p>之后就会把这里构建出来的Target对象传入到GenericRequest当中，而Glide在图片加载完成之后又会回调GenericRequest的onResourceReady()方法，我们来看一下这部分源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final class GenericRequest&lt;A, T, Z, R&gt; implements Request, SizeReadyCallback,</span><br><span class="line">        ResourceCallback &#123;</span><br><span class="line"></span><br><span class="line">    private Target&lt;R&gt; target;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private void onResourceReady(Resource&lt;?&gt; resource, R result) &#123;</span><br><span class="line">        boolean isFirstResource = isFirstReadyResource();</span><br><span class="line">        status = Status.COMPLETE;</span><br><span class="line">        this.resource = resource;</span><br><span class="line">        if (requestListener == null || !requestListener.onResourceReady(result, model, target,</span><br><span class="line">                loadedFromMemoryCache, isFirstResource)) &#123;</span><br><span class="line">            GlideAnimation&lt;R&gt; animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);</span><br><span class="line">            target.onResourceReady(result, animation);</span><br><span class="line">        &#125;</span><br><span class="line">        notifyLoadSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在第14行调用了target.onResourceReady()方法，而刚才我们已经知道，这里的target就是GlideDrawableImageViewTarget对象，那么我们再来看一下它的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class GlideDrawableImageViewTarget extends ImageViewTarget&lt;GlideDrawable&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; animation) &#123;</span><br><span class="line">        if (!resource.isAnimated()) &#123;</span><br><span class="line">            float viewRatio = view.getWidth() / (float) view.getHeight();</span><br><span class="line">            float drawableRatio = resource.getIntrinsicWidth() / (float) resource.getIntrinsicHeight();</span><br><span class="line">            if (Math.abs(viewRatio - 1f) &lt;= SQUARE_RATIO_MARGIN</span><br><span class="line">                    &amp;&amp; Math.abs(drawableRatio - 1f) &lt;= SQUARE_RATIO_MARGIN) &#123;</span><br><span class="line">                resource = new SquaringDrawable(resource, view.getWidth());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        super.onResourceReady(resource, animation);</span><br><span class="line">        this.resource = resource;</span><br><span class="line">        resource.setLoopCount(maxLoopCount);</span><br><span class="line">        resource.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void setResource(GlideDrawable resource) &#123;</span><br><span class="line">        view.setImageDrawable(resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里在onResourceReady()方法中处理了图片展示，还有GIF播放的逻辑，那么一张图片也就显示出来了，这也就是Glide回调的基本实现原理。</p>
<p>好的，那么原理就先分析到这儿，接下来我们就来看一下在回调和监听方面还有哪些知识是可以扩展的。</p>
<h1 id="into-方法"><a href="#into-方法" class="headerlink" title="into()方法"></a>into()方法</h1><p>使用了这么久的Glide，我们都知道into()方法中是可以传入ImageView的。那么into()方法还可以传入别的参数吗？我可以让Glide加载出来的图片不显示到ImageView上吗？答案是肯定的，这就需要用到自定义Target功能。</p>
<p>其实通过上面的分析，我们已经知道了，into()方法还有一个接收Target参数的重载。即使我们传入的参数是ImageView，Glide也会在内部自动构建一个Target对象。而如果我们能够掌握自定义Target技术的话，就可以更加随心所欲地控制Glide的回调了。</p>
<p>我们先来看一下Glide中Target的继承结构图吧，如下所示：</p>
<p><img src="https://img-blog.csdn.net/20170614222823388?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>可以看到，Target的继承结构还是相当复杂的，实现Target接口的子类非常多。不过你不用被这么多的子类所吓到，这些大多数都是Glide已经实现好的具备完整功能的Target子类，如果我们要进行自定义的话，通常只需要在两种Target的基础上去自定义就可以了，一种是SimpleTarget，一种是ViewTarget。</p>
<p>接下来我就分别以这两种Target来举例，学习一下自定义Target的功能。</p>
<p>首先来看SimpleTarget，顾名思义，它是一种极为简单的Target，我们使用它可以将Glide加载出来的图片对象获取到，而不是像之前那样只能将图片在ImageView上显示出来。</p>
<p>那么下面我们来看一下SimpleTarget的用法示例吧，其实非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SimpleTarget&lt;GlideDrawable&gt; simpleTarget = new SimpleTarget&lt;GlideDrawable&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onResourceReady(GlideDrawable resource, GlideAnimation glideAnimation) &#123;</span><br><span class="line">        imageView.setImageDrawable(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public void loadImage(View view) &#123;</span><br><span class="line">    String url = &quot;http://cn.bing.com/az/hprichbg/rb/TOAD_ZH-CN7336795473_1920x1080.jpg&quot;;</span><br><span class="line">    Glide.with(this)</span><br><span class="line">         .load(url)</span><br><span class="line">         .into(simpleTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么样？不愧是SimpleTarget吧，短短几行代码就搞定了。这里我们创建了一个SimpleTarget的实例，并且指定它的泛型是GlideDrawable，然后重写了onResourceReady()方法。在onResourceReady()方法中，我们就可以获取到Glide加载出来的图片对象了，也就是方法参数中传过来的GlideDrawable对象。有了这个对象之后你可以使用它进行任意的逻辑操作，这里我只是简单地把它显示到了ImageView上。</p>
<p>SimpleTarget的实现创建好了，那么只需要在加载图片的时候将它传入到into()方法中就可以了，现在运行一下程序，效果如下图所示。</p>
<p><img src="https://img-blog.csdn.net/20170615212142394" alt=""></p>
<p>虽然目前这个效果和直接在into()方法中传入ImageView并没有什么区别，但是我们已经拿到了图片对象的实例，然后就可以随意做更多的事情了。</p>
<p>当然，SimpleTarget中的泛型并不一定只能是GlideDrawable，如果你能确定你正在加载的是一张静态图而不是GIF图的话，我们还能直接拿到这张图的Bitmap对象，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SimpleTarget&lt;Bitmap&gt; simpleTarget = new SimpleTarget&lt;Bitmap&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onResourceReady(Bitmap resource, GlideAnimation glideAnimation) &#123;</span><br><span class="line">        imageView.setImageBitmap(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public void loadImage(View view) &#123;</span><br><span class="line">    String url = &quot;http://cn.bing.com/az/hprichbg/rb/TOAD_ZH-CN7336795473_1920x1080.jpg&quot;;</span><br><span class="line">    Glide.with(this)</span><br><span class="line">         .load(url)</span><br><span class="line">         .asBitmap()</span><br><span class="line">         .into(simpleTarget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SimpleTarget后面的泛型一般可以是 Bitmap，GlideDrawable，GifDrawable，这个和load方法之后的处理有关，如果确认是bitmap调用asBitmap（）方法的话SimpleTarget的泛型为Bitmap，如果调用asGif（）则泛型为GifDrawable，默认情况下则为GlideDrawable。</p>
</blockquote>
<p>可以看到，这里我们将SimpleTarget的泛型指定成Bitmap，然后在加载图片的时候调用了asBitmap()方法强制指定这是一张静态图，这样就能在onResourceReady()方法中获取到这张图的Bitmap对象了。</p>
<p>好了，SimpleTarget的用法就是这么简单，接下来我们学习一下ViewTarget的用法。</p>
<p>事实上，从刚才的继承结构图上就能看出，Glide在内部自动帮我们创建的GlideDrawableImageViewTarget就是ViewTarget的子类。只不过GlideDrawableImageViewTarget被限定只能作用在ImageView上，而ViewTarget的功能更加广泛，它可以作用在任意的View上。</p>
<p>这里我们还是通过一个例子来演示一下吧，比如我创建了一个自定义布局MyLayout，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyLayout extends LinearLayout &#123;</span><br><span class="line"></span><br><span class="line">    private ViewTarget&lt;MyLayout, GlideDrawable&gt; viewTarget;</span><br><span class="line"></span><br><span class="line">    public MyLayout(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        viewTarget = new ViewTarget&lt;MyLayout, GlideDrawable&gt;(this) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onResourceReady(GlideDrawable resource, GlideAnimation glideAnimation) &#123;</span><br><span class="line">                MyLayout myLayout = getView();</span><br><span class="line">                myLayout.setImageAsBackground(resource);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ViewTarget&lt;MyLayout, GlideDrawable&gt; getTarget() &#123;</span><br><span class="line">        return viewTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setImageAsBackground(GlideDrawable resource) &#123;</span><br><span class="line">        setBackground(resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在MyLayout的构造函数中，我们创建了一个ViewTarget的实例，并将Mylayout当前的实例this传了进去。ViewTarget中需要指定两个泛型，一个是View的类型，一个图片的类型（GlideDrawable或Bitmap）。然后在onResourceReady()方法中，我们就可以通过getView()方法获取到MyLayout的实例，并调用它的任意接口了。比如说这里我们调用了setImageAsBackground()方法来将加载出来的图片作为MyLayout布局的背景图。</p>
<p>接下来看一下怎么使用这个Target吧，由于MyLayout中已经提供了getTarget()接口，我们只需要在加载图片的地方这样写就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    MyLayout myLayout;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        myLayout = (MyLayout) findViewById(R.id.background);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void loadImage(View view) &#123;</span><br><span class="line">        String url = &quot;http://cn.bing.com/az/hprichbg/rb/TOAD_ZH-CN7336795473_1920x1080.jpg&quot;;</span><br><span class="line">        Glide.with(this)</span><br><span class="line">             .load(url)</span><br><span class="line">             .into(myLayout.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20170615225048126" alt=""></p>
<p>好的，关于自定义Target的功能我们就介绍这么多，这些虽说都是自定义Target最基本的用法，但掌握了这些用法之后，你就能应对各种各样复杂的逻辑了。</p>
<h1 id="preload-方法"><a href="#preload-方法" class="headerlink" title="preload()方法"></a>preload()方法</h1><p>Glide加载图片虽说非常智能，它会自动判断该图片是否已经有缓存了，如果有的话就直接从缓存中读取，没有的话再从网络去下载。但是如果我希望提前对图片进行一个预加载，等真正需要加载图片的时候就直接从缓存中读取，不想再等待慢长的网络加载时间了，这该怎么办呢？\</p>
<p>对于很多Glide新手来说这确实是一个烦恼的问题，因为在没有学习本篇文章之前，into()方法中必须传入一个ImageView呀，而传了ImageView之后图片就显示出来了，这还怎么预加载呢？</p>
<p>不过在学习了本篇文章之后，相信你已经能够想到解决方案了。因为into()方法中除了传入ImageView之后还可以传入Target对象，如果我们在Target对象的onResourceReady()方法中做一个空实现，也就是不做任何逻辑处理，那么图片自然也就显示不出来了，而Glide的缓存机制却仍然还会正常工作，这样不就实现预加载功能了吗？</p>
<p>没错，上述的做法完全可以实现预加载功能，不过有没有感觉这种实现方式有点笨笨的。事实上，Glide专门给我们提供了预加载的接口，也就是preload()方法，我们只需要直接使用就可以了。</p>
<p>preload()方法有两个方法重载，一个不带参数，表示将会加载图片的原始尺寸，另一个可以通过参数指定加载图片的宽和高。</p>
<p>preload()方法的用法也非常简单，直接使用它来替换into()方法即可，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .diskCacheStrategy(DiskCacheStrategy.SOURCE)</span><br><span class="line">     .preload();</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，我们如果使用了preload()方法，最好要将diskCacheStrategy的缓存策略指定成DiskCacheStrategy.SOURCE。因为preload()方法默认是预加载的原始图片大小，而into()方法则默认会根据ImageView控件的大小来动态决定加载图片的大小。因此，如果不将diskCacheStrategy的缓存策略指定成DiskCacheStrategy.SOURCE的话，很容易会造成我们在预加载完成之后再使用into()方法加载图片，却仍然还是要从网络上去请求图片这种现象。</p>
<p>调用了预加载之后，我们以后想再去加载这张图片就会非常快了，因为Glide会直接从缓存当中去读取图片并显示出来，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">     .load(url)</span><br><span class="line">     .diskCacheStrategy(DiskCacheStrategy.SOURCE)</span><br><span class="line">     .into(imageView);</span><br></pre></td></tr></table></figure>
<p>注意，这里我们仍然需要使用diskCacheStrategy()方法将硬盘缓存策略指定成DiskCacheStrategy.SOURCE，以保证Glide一定会去读取刚才预加载的图片缓存。</p>
<p>preload()方法的用法大概就是这么简单，但是仅仅会使用显然层次有些太低了，下面我们就满足一下好奇心，看看它的源码是如何实现的。</p>
<p>和into()方法一样，preload()方法也是在GenericRequestBuilder类当中的，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; implements Cloneable &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public Target&lt;TranscodeType&gt; preload(int width, int height) &#123;</span><br><span class="line">        final PreloadTarget&lt;TranscodeType&gt; target = PreloadTarget.obtain(width, height);</span><br><span class="line">        return into(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Target&lt;TranscodeType&gt; preload() &#123;</span><br><span class="line">        return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如刚才所说，preload()方法有两个方法重载，你可以调用带参数的preload()方法来明确指定图片的宽和高，也可以调用不带参数的preload()方法，它会在内部自动将图片的宽和高都指定成Target.SIZE_ORIGINAL，也就是图片的原始尺寸。</p>
<p>然后我们可以看到，这里在第5行调用了PreloadTarget.obtain()方法获取一个PreloadTarget的实例，并把它传入到了into()方法当中。从刚才的继承结构图中可以看出，PreloadTarget是SimpleTarget的子类，因此它是可以直接传入到into()方法中的。</p>
<p>那么现在的问题就是，PreloadTarget具体的实现到底是什么样子的了，我们看一下它的源码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class PreloadTarget&lt;Z&gt; extends SimpleTarget&lt;Z&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;Z&gt; PreloadTarget&lt;Z&gt; obtain(int width, int height) &#123;</span><br><span class="line">        return new PreloadTarget&lt;Z&gt;(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private PreloadTarget(int width, int height) &#123;</span><br><span class="line">        super(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onResourceReady(Z resource, GlideAnimation&lt;? super Z&gt; glideAnimation) &#123;</span><br><span class="line">        Glide.clear(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PreloadTarget的源码非常简单，obtain()方法中就是new了一个PreloadTarget的实例而已，而onResourceReady()方法中也没做什么事情，只是调用了Glide.clear()方法。</p>
<p>这里的Glide.clear()并不是清空缓存的意思，而是表示加载已完成，释放资源的意思，因此不用在这里产生疑惑。</p>
<p>其实PreloadTarget的思想和我们刚才提到设计思路是一样的，就是什么都不做就可以了。因为图片加载完成之后只将它缓存而不去显示它，那不就相当于预加载了嘛。</p>
<p>preload()方法不管是在用法方面还是源码实现方面都还是非常简单的，那么关于这个方法我们就学到这里。</p>
<h1 id="downloadOnly-方法"><a href="#downloadOnly-方法" class="headerlink" title="downloadOnly()方法"></a>downloadOnly()方法</h1><p>一直以来，我们使用Glide都是为了将图片显示到界面上。虽然我们知道Glide会在图片的加载过程中对图片进行缓存，但是缓存文件到底是存在哪里的，以及如何去直接访问这些缓存文件？我们都还不知道。</p>
<p>其实Glide将图片加载接口设计成这样也是希望我们使用起来更加的方便，不用过多去考虑底层的实现细节。但如果我现在就是想要去访问图片的缓存文件该怎么办呢？这就需要用到downloadOnly()方法了。</p>
<p>和preload()方法类似，downloadOnly()方法也是可以替换into()方法的，不过downloadOnly()方法的用法明显要比preload()方法复杂不少。顾名思义，downloadOnly()方法表示只会下载图片，而不会对图片进行加载。当图片下载完成之后，我们可以得到图片的存储路径，以便后续进行操作。</p>
<p>那么首先我们还是先来看下基本用法。downloadOnly()方法是定义在DrawableTypeRequest类当中的，它有两个方法重载，一个接收图片的宽度和高度，另一个接收一个泛型对象，如下所示：</p>
<ul>
<li>downloadOnly(int width, int height)</li>
<li>downloadOnly(Y target)</li>
</ul>
<p>这两个方法各自有各自的应用场景，其中downloadOnly(int width, int height)是用于在子线程中下载图片的，而downloadOnly(Y target)是用于在主线程中下载图片的。</p>
<p>那么我们先来看downloadOnly(int width, int height)的用法。当调用了downloadOnly(int width, int height)方法后会立即返回一个FutureTarget对象，然后Glide会在后台开始下载图片文件。接下来我们调用FutureTarget的get()方法就可以去获取下载好的图片文件了，如果此时图片还没有下载完，那么get()方法就会阻塞住，一直等到图片下载完成才会有值返回。</p>
<p>下面我们通过一个例子来演示一下吧，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void downloadImage(View view) &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String url = &quot;http://cn.bing.com/az/hprichbg/rb/TOAD_ZH-CN7336795473_1920x1080.jpg&quot;;</span><br><span class="line">                final Context context = getApplicationContext();</span><br><span class="line">                FutureTarget&lt;File&gt; target = Glide.with(context)</span><br><span class="line">                                                 .load(url)</span><br><span class="line">                                                 .downloadOnly(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);</span><br><span class="line">                final File imageFile = target.get();</span><br><span class="line">                runOnUiThread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        Toast.makeText(context, imageFile.getPath(), Toast.LENGTH_LONG).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码稍微有一点点长，我带着大家解读一下。首先刚才说了，downloadOnly(int width, int height)方法必须要用在子线程当中，因此这里的第一步就是new了一个Thread。在子线程当中，我们先获取了一个Application Context，这个时候不能再用Activity作为Context了，因为会有Activity销毁了但子线程还没执行完这种可能出现。</p>
<p>接下来就是Glide的基本用法，只不过将into()方法替换成了downloadOnly()方法。downloadOnly()方法会返回一个FutureTarget对象，这个时候其实Glide已经开始在后台下载图片了，我们随时都可以调用FutureTarget的get()方法来获取下载的图片文件，只不过如果图片还没下载好线程会暂时阻塞住，等下载完成了才会把图片的File对象返回。</p>
<p>最后，我们使用runOnUiThread()切回到主线程，然后使用Toast将下载好的图片文件路径显示出来。</p>
<p>现在重新运行一下代码，效果如下图所示。<br><img src="https://img-blog.csdn.net/20170616223448840" alt=""></p>
<p>这样我们就能清晰地看出来图片完整的缓存路径是什么了。</p>
<p>之后我们可以使用如下代码去加载这张图片，图片就会立即显示出来，而不用再去网络上请求了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void loadImage(View view) &#123;</span><br><span class="line">    String url = &quot;http://cn.bing.com/az/hprichbg/rb/TOAD_ZH-CN7336795473_1920x1080.jpg&quot;;</span><br><span class="line">    Glide.with(this)</span><br><span class="line">            .load(url)</span><br><span class="line">            .diskCacheStrategy(DiskCacheStrategy.SOURCE)</span><br><span class="line">            .into(imageView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，这里必须将硬盘缓存策略指定成DiskCacheStrategy.SOURCE或者DiskCacheStrategy.ALL，否则Glide将无法使用我们刚才下载好的图片缓存文件。</p>
<p>现在重新运行一下代码，效果如下图所示。<br><img src="https://img-blog.csdn.net/20170616223618749" alt=""></p>
<p>可以看到，图片的加载和显示是非常快的，因为Glide直接使用的是刚才下载好的缓存文件。</p>
<p>那么这个downloadOnly(int width, int height)方法的工作原理到底是什么样的呢？我们来简单快速地看一下它的源码吧。</p>
<p>首先在DrawableTypeRequest类当中可以找到定义这个方法的地方，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DrawableTypeRequest&lt;ModelType&gt; extends DrawableRequestBuilder&lt;ModelType&gt;</span><br><span class="line">        implements DownloadOptions &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public FutureTarget&lt;File&gt; downloadOnly(int width, int height) &#123;</span><br><span class="line">        return getDownloadOnlyRequest().downloadOnly(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private GenericTranscodeRequest&lt;ModelType, InputStream, File&gt; getDownloadOnlyRequest() &#123;</span><br><span class="line">        return optionsApplier.apply(new GenericTranscodeRequest&lt;ModelType, InputStream, File&gt;(</span><br><span class="line">            File.class, this, streamModelLoader, InputStream.class, File.class, optionsApplier));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会先调用getDownloadOnlyRequest()方法得到一个GenericTranscodeRequest对象，然后再调用它的downloadOnly()方法，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTranscodeRequest&lt;ModelType, DataType, ResourceType&gt;</span><br><span class="line">    implements DownloadOptions &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public FutureTarget&lt;File&gt; downloadOnly(int width, int height) &#123;</span><br><span class="line">        return getDownloadOnlyRequest().into(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private GenericRequestBuilder&lt;ModelType, DataType, File, File&gt; getDownloadOnlyRequest() &#123;</span><br><span class="line">        ResourceTranscoder&lt;File, File&gt; transcoder = UnitTranscoder.get();</span><br><span class="line">        DataLoadProvider&lt;DataType, File&gt; dataLoadProvider = glide.buildDataProvider(dataClass, File.class);</span><br><span class="line">        FixedLoadProvider&lt;ModelType, DataType, File, File&gt; fixedLoadProvider =</span><br><span class="line">            new FixedLoadProvider&lt;ModelType, DataType, File, File&gt;(modelLoader, transcoder, dataLoadProvider);</span><br><span class="line">        return optionsApplier.apply(</span><br><span class="line">                new GenericRequestBuilder&lt;ModelType, DataType, File, File&gt;(fixedLoadProvider,</span><br><span class="line">                File.class, this))</span><br><span class="line">                .priority(Priority.LOW)</span><br><span class="line">                .diskCacheStrategy(DiskCacheStrategy.SOURCE)</span><br><span class="line">                .skipMemoryCache(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里又是调用了一个getDownloadOnlyRequest()方法来构建了一个图片下载的请求，getDownloadOnlyRequest()方法会返回一个GenericRequestBuilder对象，接着调用它的into(width, height)方法，我们继续跟进去瞧一瞧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public FutureTarget&lt;TranscodeType&gt; into(int width, int height) &#123;</span><br><span class="line">    final RequestFutureTarget&lt;ModelType, TranscodeType&gt; target =</span><br><span class="line">            new RequestFutureTarget&lt;ModelType, TranscodeType&gt;(glide.getMainHandler(), width, height);</span><br><span class="line">    glide.getMainHandler().post(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (!target.isCancelled()) &#123;</span><br><span class="line">                into(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里首先是new出了一个RequestFutureTarget对象，RequestFutureTarget也是Target的子类之一。然后通过Handler将线程切回到主线程当中，再将这个RequestFutureTarget传入到into()方法当中。</p>
<p>那么也就是说，其实这里就是调用了接收Target参数的into()方法，然后Glide就开始执行正常的图片加载逻辑了。那么现在剩下的问题就是，这个RequestFutureTarget中到底处理了些什么逻辑？我们打开它的源码看一看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">public class RequestFutureTarget&lt;T, R&gt; implements FutureTarget&lt;R&gt;, Runnable &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public R get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return doGet(null);</span><br><span class="line">        &#125; catch (TimeoutException e) &#123;</span><br><span class="line">            throw new AssertionError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public R get(long time, TimeUnit timeUnit) throws InterruptedException, ExecutionException, </span><br><span class="line">        TimeoutException &#123;</span><br><span class="line">        return doGet(timeUnit.toMillis(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getSize(SizeReadyCallback cb) &#123;</span><br><span class="line">        cb.onSizeReady(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void onLoadFailed(Exception e, Drawable errorDrawable) &#123;</span><br><span class="line">        exceptionReceived = true;</span><br><span class="line">        this.exception = e;</span><br><span class="line">        waiter.notifyAll(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void onResourceReady(R resource, GlideAnimation&lt;? super R&gt; glideAnimation) &#123;</span><br><span class="line">        resultReceived = true;</span><br><span class="line">        this.resource = resource;</span><br><span class="line">        waiter.notifyAll(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized R doGet(Long timeoutMillis) throws ExecutionException, InterruptedException, </span><br><span class="line">        TimeoutException &#123;</span><br><span class="line">        if (assertBackgroundThread) &#123;</span><br><span class="line">            Util.assertBackgroundThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (isCancelled) &#123;</span><br><span class="line">            throw new CancellationException();</span><br><span class="line">        &#125; else if (exceptionReceived) &#123;</span><br><span class="line">            throw new ExecutionException(exception);</span><br><span class="line">        &#125; else if (resultReceived) &#123;</span><br><span class="line">            return resource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (timeoutMillis == null) &#123;</span><br><span class="line">            waiter.waitForTimeout(this, 0);</span><br><span class="line">        &#125; else if (timeoutMillis &gt; 0) &#123;</span><br><span class="line">            waiter.waitForTimeout(this, timeoutMillis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125; else if (exceptionReceived) &#123;</span><br><span class="line">            throw new ExecutionException(exception);</span><br><span class="line">        &#125; else if (isCancelled) &#123;</span><br><span class="line">            throw new CancellationException();</span><br><span class="line">        &#125; else if (!resultReceived) &#123;</span><br><span class="line">            throw new TimeoutException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Waiter &#123;</span><br><span class="line"></span><br><span class="line">        public void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException &#123;</span><br><span class="line">            toWaitOn.wait(timeoutMillis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void notifyAll(Object toNotify) &#123;</span><br><span class="line">            toNotify.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我对RequestFutureTarget的源码做了一些精简，我们只看最主要的逻辑就可以了。</p>
<p>刚才我们已经学习过了downloadOnly()方法的基本用法，在调用了downloadOnly()方法之后，再调用FutureTarget的get()方法，就能获取到下载的图片文件了。而downloadOnly()方法返回的FutureTarget对象其实就是这个RequestFutureTarget，因此我们直接来看它的get()方法就行了。</p>
<p>RequestFutureTarget的get()方法中又调用了一个doGet()方法，而doGet()方法才是真正处理具体逻辑的地方。首先在doGet()方法中会判断当前是否是在子线程当中，如果不是的话会直接抛出一个异常。然后下面会判断下载是否已取消、或者已失败，如果是已取消或者已失败的话都会直接抛出一个异常。接下来会根据resultReceived这个变量来判断下载是否已完成，如果这个变量为true的话，就直接把结果进行返回。</p>
<p>那么如果下载还没有完成呢？我们继续往下看，接下来就进入到一个wait()当中，把当前线程给阻塞住，从而阻止代码继续往下执行。这也是为什么downloadOnly(int width, int height)方法要求必须在子线程当中使用，因为它会对当前线程进行阻塞，如果在主线程当中使用的话，那么就会让主线程卡死，从而用户无法进行任何其他操作。</p>
<p>那么现在线程被阻塞住了，什么时候才能恢复呢？答案在onResourceReady()方法中。可以看到，onResourceReady()方法中只有三行代码，第一行把resultReceived赋值成true，说明图片文件已经下载好了，这样下次再调用get()方法时就不会再阻塞线程，而是可以直接将结果返回。第二行把下载好的图片文件赋值到一个全局的resource变量上面，这样doGet()方法就也可以访问到它。第三行notifyAll一下，通知所有wait的线程取消阻塞，这个时候图片文件已经下载好了，因此doGet()方法也就可以返回结果了。</p>
<p>好的，这就是downloadOnly(int width, int height)方法的基本用法和实现原理，那么下面我们来看一下downloadOnly(Y target)方法。</p>
<p>回想一下，其实downloadOnly(int width, int height)方法必须使用在子线程当中，最主要还是因为它在内部帮我们自动创建了一个RequestFutureTarget，是这个RequestFutureTarget要求必须在子线程当中执行。而downloadOnly(Y target)方法则要求我们传入一个自己创建的Target，因此就不受RequestFutureTarget的限制了。</p>
<p>但是downloadOnly(Y target)方法的用法也会相对更复杂一些，因为我们又要自己创建一个Target了，而且这次必须直接去实现最顶层的Target接口，比之前的SimpleTarget和ViewTarget都要复杂不少。</p>
<p>那么下面我们就来实现一个最简单的DownloadImageTarget吧，注意Target接口的泛型必须指定成File对象，这是downloadOnly(Y target)方法要求的，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class DownloadImageTarget implements Target&lt;File&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;DownloadImageTarget&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStart() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStop() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadStarted(Drawable placeholder) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadFailed(Exception e, Drawable errorDrawable) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onResourceReady(File resource, GlideAnimation&lt;? super File&gt; glideAnimation) &#123;</span><br><span class="line">        Log.d(TAG, resource.getPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onLoadCleared(Drawable placeholder) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getSize(SizeReadyCallback cb) &#123;</span><br><span class="line">        cb.onSizeReady(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setRequest(Request request) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Request getRequest() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于是要直接实现Target接口，因此需要重写的方法非常多。这些方法大多是数Glide加载图片生命周期的一些回调，我们可以不用管它们，其中只有两个方法是必须实现的，一个是getSize()方法，一个是onResourceReady()方法。</p>
<p>在第二篇Glide源码解析的时候，我带着大家一起分析过，Glide在开始加载图片之前会先计算图片的大小，然后回调到onSizeReady()方法当中，之后才会开始执行图片加载。而这里，计算图片大小的任务就交给我们了。只不过这是一个最简单的Target实现，我在getSize()方法中就直接回调了Target.SIZE_ORIGINAL，表示图片的原始尺寸。</p>
<p>然后onResourceReady()方法我们就非常熟悉了，图片下载完成之后就会回调到这里，我在这个方法中只是打印了一下下载的图片文件的路径。</p>
<p>这样一个最简单的DownloadImageTarget就定义好了，使用它也非常的简单，我们不用再考虑什么线程的问题了，而是直接把它的实例传入downloadOnly(Y target)方法中即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void downloadImage(View view) &#123;</span><br><span class="line">    String url = &quot;http://cn.bing.com/az/hprichbg/rb/TOAD_ZH-CN7336795473_1920x1080.jpg&quot;;</span><br><span class="line">    Glide.with(this)</span><br><span class="line">            .load(url)</span><br><span class="line">            .downloadOnly(new DownloadImageTarget());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在重新运行一下代码并点击Download Image按钮，然后观察控制台日志的输出，结果如下图所示。<br><img src="https://img-blog.csdn.net/20170617112709246?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>这样我们就使用了downloadOnly(Y target)方法同样获取到下载的图片文件的缓存路径了。</p>
<p>好的，那么关于downloadOnly()方法我们就学到这里。</p>
<blockquote>
<p>关于downloadonly方法和preload方法的实际应用场景是不同的，preload适用于只需要缓存未来适用的情况。适用比较简单。downloadonly一般使用在需要使用缓存文件对象的地方，使用相对preload麻烦一点</p>
</blockquote>
<h1 id="listener-方法"><a href="#listener-方法" class="headerlink" title="listener()方法"></a>listener()方法</h1><p>今天学习的内容已经够多了，下面我们就以一个简单的知识点结尾吧，Glide回调与监听的最后一部分——listener()方法。</p>
<p>其实listener()方法的作用非常普遍，它可以用来监听Glide加载图片的状态。举个例子，比如说我们刚才使用了preload()方法来对图片进行预加载，但是我怎样确定预加载有没有完成呢？还有如果Glide加载图片失败了，我该怎样调试错误的原因呢？答案都在listener()方法当中。</p>
<p>首先来看下listener()方法的基本用法吧，不同于刚才几个方法都是要替换into()方法的，listener()是结合into()方法一起使用的，当然也可以结合preload()方法一起使用。最基本的用法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void loadImage(View view) &#123;</span><br><span class="line">    String url = &quot;http://cn.bing.com/az/hprichbg/rb/TOAD_ZH-CN7336795473_1920x1080.jpg&quot;;</span><br><span class="line">    Glide.with(this)</span><br><span class="line">            .load(url)</span><br><span class="line">            .listener(new RequestListener&lt;String, GlideDrawable&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public boolean onException(Exception e, String model, Target&lt;GlideDrawable&gt; target,</span><br><span class="line">                    boolean isFirstResource) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public boolean onResourceReady(GlideDrawable resource, String model,</span><br><span class="line">                    Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .into(imageView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们在into()方法之前串接了一个listener()方法，然后实现了一个RequestListener的实例。其中RequestListener需要实现两个方法，一个onResourceReady()方法，一个onException()方法。从方法名上就可以看出来了，当图片加载完成的时候就会回调onResourceReady()方法，而当图片加载失败的时候就会回调onException()方法，onException()方法中会将失败的Exception参数传进来，这样我们就可以定位具体失败的原因了。</p>
<p>没错，listener()方法就是这么简单。不过还有一点需要处理，onResourceReady()方法和onException()方法都有一个布尔值的返回值，返回false就表示这个事件没有被处理，还会继续向下传递，返回true就表示这个事件已经被处理掉了，从而不会再继续向下传递。举个简单点的例子，如果我们在RequestListener的onResourceReady()方法中返回了true，那么就不会再回调Target的onResourceReady()方法了。</p>
<p>关于listener()方法的用法就讲这么多，不过还是老规矩，我们再来看一下它的源码是怎么实现的吧。</p>
<p>首先，listener()方法是定义在GenericRequestBuilder类当中的，而我们传入到listener()方法中的实例则会赋值到一个requestListener变量当中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    private RequestListener&lt;? super ModelType, TranscodeType&gt; requestListener;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; listener(</span><br><span class="line">            RequestListener&lt;? super ModelType, TranscodeType&gt; requestListener) &#123;</span><br><span class="line">        this.requestListener = requestListener;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在构建GenericRequest的时候这个变量也会被一起传进去，最后在图片加载完成的时候，我们会看到如下逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public final class GenericRequest&lt;A, T, Z, R&gt; implements Request, SizeReadyCallback,</span><br><span class="line">        ResourceCallback &#123;</span><br><span class="line"></span><br><span class="line">    private RequestListener&lt;? super A, R&gt; requestListener;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private void onResourceReady(Resource&lt;?&gt; resource, R result) &#123;</span><br><span class="line">        boolean isFirstResource = isFirstReadyResource();</span><br><span class="line">        status = Status.COMPLETE;</span><br><span class="line">        this.resource = resource;</span><br><span class="line">        if (requestListener == null || !requestListener.onResourceReady(result, model, target,</span><br><span class="line">                loadedFromMemoryCache, isFirstResource)) &#123;</span><br><span class="line">            GlideAnimation&lt;R&gt; animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);</span><br><span class="line">            target.onResourceReady(result, animation);</span><br><span class="line">        &#125;</span><br><span class="line">        notifyLoadSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里在第11行会先回调requestListener的onResourceReady()方法，只有当这个onResourceReady()方法返回false的时候，才会继续调用Target的onResourceReady()方法，这也就是listener()方法的实现原理。</p>
<p>另外一个onException()方法的实现机制也是一模一样的，代码同样是在GenericRequest类中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class GenericRequest&lt;A, T, Z, R&gt; implements Request, SizeReadyCallback,</span><br><span class="line">        ResourceCallback &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onException(Exception e) &#123;</span><br><span class="line">        status = Status.FAILED;</span><br><span class="line">        if (requestListener == null || </span><br><span class="line">                !requestListener.onException(e, model, target, isFirstReadyResource())) &#123;</span><br><span class="line">            setErrorPlaceholder(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里会在第9行回调requestListener的onException()方法，只有在onException()方法返回false的情况下才会继续调用setErrorPlaceholder()方法。也就是说，如果我们在onException()方法中返回了true，那么Glide请求中使用error(int resourceId)方法设置的异常占位图就失效了。</p>
<p>这样我们也就将listener()方法的全部实现原理都分析完了。</p>
<p>好了，关于Glide回调与监听方面的内容今天就讲到这里，这一篇文章的内容非常充实，希望大家都能好好掌握。下一篇文章当中，我会继续带着大家深入分析Glide的其他功能模块，讲一讲图片变换方面的知识，感兴趣的朋友请继续阅读 <a href="http://blog.csdn.net/guolin_blog/article/details/71524668" target="_blank" rel="noopener">Android图片加载框架最全解析（五），Glide强大的图片变换功能</a> 。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/08/Android图片加载框架最全解析（三），深入探究Glide的缓存机制/" rel="next" title="Android图片加载框架最全解析（三），深入探究Glide的缓存机制">
                <i class="fa fa-chevron-left"></i> Android图片加载框架最全解析（三），深入探究Glide的缓存机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/11/Android-设计模式：（一）面向对象的六大原则/" rel="prev" title="Android 设计模式：（一）面向对象的六大原则">
                Android 设计模式：（一）面向对象的六大原则 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/headers.png"
                alt="zzh" />
            
              <p class="site-author-name" itemprop="name">zzh</p>
              <p class="site-description motion-element" itemprop="description">zzh个人博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zzh1026" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.zhihu.com/people/zzh1026it" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/zzh1026" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#声明"><span class="nav-number">1.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#回调的源码实现"><span class="nav-number">2.</span> <span class="nav-text">回调的源码实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#into-方法"><span class="nav-number">3.</span> <span class="nav-text">into()方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#preload-方法"><span class="nav-number">4.</span> <span class="nav-text">preload()方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#downloadOnly-方法"><span class="nav-number">5.</span> <span class="nav-text">downloadOnly()方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#listener-方法"><span class="nav-number">6.</span> <span class="nav-text">listener()方法</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zzh</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
